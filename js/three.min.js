(function(global){
  'use strict';
  function clamp(v,min,max){return v<min?min:(v>max?max:v);} 
  class Vector3{
    constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z;}
    set(x,y,z){this.x=x;this.y=y;this.z=z;return this;}
    clone(){return new Vector3(this.x,this.y,this.z);} 
    add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}
    sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}
    multiplyScalar(s){this.x*=s;this.y*=s;this.z*=s;return this;}
  }
  class Color{
    constructor(hex=0xffffff){this.set(hex);} 
    set(hex){if(typeof hex==='string'){if(hex[0]==='#') hex=hex.slice(1); this.r=parseInt(hex.substring(0,2),16)/255; this.g=parseInt(hex.substring(2,4),16)/255; this.b=parseInt(hex.substring(4,6),16)/255;}
      else{this.r=((hex>>16)&255)/255; this.g=((hex>>8)&255)/255; this.b=(hex&255)/255;} return this;}
  }
  class Matrix4{
    constructor(){this.elements=new Float32Array(16);this.identity();}
    identity(){const e=this.elements; e[0]=1;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=1;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[10]=1;e[11]=0;e[12]=0;e[13]=0;e[14]=0;e[15]=1;return this;}
    multiply(m){return this.multiplyMatrices(this,m);} 
    multiplyMatrices(a,b){const ae=a.elements,be=b.elements,te=this.elements;
      const a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];
      const a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];
      const a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];
      const a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];
      const b11=be[0],b12=be[4],b13=be[8],b14=be[12];
      const b21=be[1],b22=be[5],b23=be[9],b24=be[13];
      const b31=be[2],b32=be[6],b33=be[10],b34=be[14];
      const b41=be[3],b42=be[7],b43=be[11],b44=be[15];
      te[0]=a11*b11+a12*b21+a13*b31+a14*b41;
      te[4]=a11*b12+a12*b22+a13*b32+a14*b42;
      te[8]=a11*b13+a12*b23+a13*b33+a14*b43;
      te[12]=a11*b14+a12*b24+a13*b34+a14*b44;
      te[1]=a21*b11+a22*b21+a23*b31+a24*b41;
      te[5]=a21*b12+a22*b22+a23*b32+a24*b42;
      te[9]=a21*b13+a22*b23+a23*b33+a24*b43;
      te[13]=a21*b14+a22*b24+a23*b34+a24*b44;
      te[2]=a31*b11+a32*b21+a33*b31+a34*b41;
      te[6]=a31*b12+a32*b22+a33*b32+a34*b42;
      te[10]=a31*b13+a32*b23+a33*b33+a34*b43;
      te[14]=a31*b14+a32*b24+a33*b34+a34*b44;
      te[3]=a41*b11+a42*b21+a43*b31+a44*b41;
      te[7]=a41*b12+a42*b22+a43*b32+a44*b42;
      te[11]=a41*b13+a42*b23+a43*b33+a44*b43;
      te[15]=a41*b14+a42*b24+a43*b34+a44*b44;
      return this;}
    makeTranslation(x,y,z){this.identity();const e=this.elements;e[12]=x;e[13]=y;e[14]=z;return this;}
    makeRotationY(theta){this.identity();const c=Math.cos(theta),s=Math.sin(theta);const e=this.elements;e[0]=c;e[2]=s;e[8]=-s;e[10]=c;return this;}
    makeScale(x,y,z){this.identity();const e=this.elements;e[0]=x;e[5]=y;e[10]=z;return this;}
    makePerspective(fov,aspect,near,far){const te=this.elements;const f=1/Math.tan((fov*Math.PI/180)/2);const nf=1/(near-far);te[0]=f/aspect;te[1]=0;te[2]=0;te[3]=0;te[4]=0;te[5]=f;te[6]=0;te[7]=0;te[8]=0;te[9]=0;te[10]=(far+near)*nf;te[11]=-1;te[12]=0;te[13]=0;te[14]=2*far*near*nf;te[15]=0;return this;}
    multiplyScalar(s){const te=this.elements;for(let i=0;i<16;i++)te[i]*=s;return this;}
    clone(){const m=new Matrix4();m.elements.set(this.elements);return m;}
  }
  class Object3D{
    constructor(){this.position=new Vector3();this.rotation=new Vector3();this.scale=new Vector3(1,1,1);this.children=[];this.parent=null;this.matrix=new Matrix4();this.worldMatrix=new Matrix4();}
    add(obj){if(obj.parent) obj.parent.remove(obj);this.children.push(obj);obj.parent=this;}
    remove(obj){this.children=this.children.filter(c=>c!==obj);obj.parent=null;}
    updateMatrix(){const t=new Matrix4().makeTranslation(this.position.x,this.position.y,this.position.z);
      const rY=new Matrix4().makeRotationY(this.rotation.y);
      const s=new Matrix4().makeScale(this.scale.x,this.scale.y,this.scale.z);
      this.matrix=t.clone().multiply(rY).multiply(s);return this.matrix;}
    updateWorldMatrix(parentMatrix){this.updateMatrix();if(parentMatrix){this.worldMatrix.multiplyMatrices(parentMatrix,this.matrix);}else{this.worldMatrix=this.matrix.clone();}
      this.children.forEach(c=>c.updateWorldMatrix(this.worldMatrix));
    }
  }
  class Scene extends Object3D{constructor(){super();this.background=new Color(0x000000);}}
  class PerspectiveCamera extends Object3D{
    constructor(fov=60,aspect=1,near=0.1,far=200){super();this.fov=fov;this.aspect=aspect;this.near=near;this.far=far;this.projectionMatrix=new Matrix4();this.updateProjectionMatrix();this.viewMatrix=new Matrix4();}
    updateProjectionMatrix(){this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far);} 
    lookAt(v){const z=new Vector3(this.position.x-v.x,this.position.y-v.y,this.position.z-v.z);
      const len=Math.hypot(z.x,z.y,z.z)||1;z.multiplyScalar(1/len);
      const up=new Vector3(0,1,0);
      const x=new Vector3(up.y*z.z-up.z*z.y,up.z*z.x-up.x*z.z,up.x*z.y-up.y*z.x);
      const xlen=Math.hypot(x.x,x.y,x.z)||1;x.multiplyScalar(1/xlen);
      const y=new Vector3(z.y*x.z-z.z*x.y,z.z*x.x-z.x*x.z,z.x*x.y-z.y*x.x);
      const e=this.viewMatrix.elements;
      e[0]=x.x;e[4]=x.y;e[8]=x.z;e[12]=-(x.x*this.position.x+x.y*this.position.y+x.z*this.position.z);
      e[1]=y.x;e[5]=y.y;e[9]=y.z;e[13]=-(y.x*this.position.x+y.y*this.position.y+y.z*this.position.z);
      e[2]=z.x;e[6]=z.y;e[10]=z.z;e[14]=-(z.x*this.position.x+z.y*this.position.y+z.z*this.position.z);
      e[3]=0;e[7]=0;e[11]=0;e[15]=1;
    }
  }
  class Geometry{constructor(){this.vertices=null;this.normals=null;this.indices=null;}}
  class BoxGeometry extends Geometry{
    constructor(w=1,h=1,d=1){super();w/=2;h/=2;d/=2;
      this.vertices=new Float32Array([
        -w,-h, d, w,-h, d, w, h, d, -w, h, d, // front
        w,-h,-d,-w,-h,-d,-w, h,-d, w, h,-d, // back
        -w, h, d, w, h, d, w, h,-d,-w, h,-d, // top
        -w,-h,-d, w,-h,-d, w,-h, d,-w,-h, d, // bottom
        -w,-h,-d,-w,-h, d,-w, h, d,-w, h,-d, // left
        w,-h, d, w,-h,-d, w, h,-d, w, h, d // right
      ]);
      this.normals=new Float32Array([
        0,0,1,0,0,1,0,0,1,0,0,1,
        0,0,-1,0,0,-1,0,0,-1,0,0,-1,
        0,1,0,0,1,0,0,1,0,0,1,0,
        0,-1,0,0,-1,0,0,-1,0,0,-1,0,
        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
        1,0,0,1,0,0,1,0,0,1,0,0
      ]);
      this.indices=new Uint16Array([
        0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,
        12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23
      ]);
    }
  }
  class PlaneGeometry extends Geometry{
    constructor(w=1,h=1){super();w/=2;h/=2;this.vertices=new Float32Array([-w,0,h,w,0,h,w,0,-h,-w,0,-h]);
      this.normals=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0]);
      this.indices=new Uint16Array([0,1,2,0,2,3]);
    }
  }
  class Group extends Object3D{constructor(){super();}}
  class MeshStandardMaterial{constructor({color=0xffffff}={}){this.color=new Color(color);} }
  class Mesh extends Object3D{constructor(geometry,material){super();this.geometry=geometry;this.material=material;}}
  class AmbientLight extends Object3D{constructor(color=0xffffff,intensity=1){super();this.color=new Color(color);this.intensity=intensity;}}
  class DirectionalLight extends Object3D{constructor(color=0xffffff,intensity=1){super();this.color=new Color(color);this.intensity=intensity;}}
  function createGLBuffer(gl,data,bufferType){const buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,data,gl.STATIC_DRAW);return buffer;}
  class WebGLRenderer{
    constructor({canvas}={}){this.canvas=canvas||document.createElement('canvas');this.gl=this.canvas.getContext('webgl');if(!this.gl) throw new Error('WebGL not supported');
      this.width=this.canvas.width;this.height=this.canvas.height;this._initProgram();}
    setSize(w,h){this.width=w;this.height=h;this.canvas.width=w;this.canvas.height=h;this.gl.viewport(0,0,w,h);} 
    _initProgram(){const gl=this.gl;const vs=`attribute vec3 position; attribute vec3 normal; uniform mat4 modelMatrix; uniform mat4 normalMatrix; uniform mat4 viewMatrix; uniform mat4 projectionMatrix; varying vec3 vNormal; void main(){vNormal = mat3(normalMatrix) * normal; gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0);} `;
      const fs=`precision mediump float; varying vec3 vNormal; uniform vec3 materialColor; uniform vec3 dirLightColor; uniform vec3 dirLightDirection; uniform vec3 ambientColor; void main(){ vec3 n = normalize(vNormal); float diff = max(dot(n, -dirLightDirection), 0.0); vec3 color = ambientColor + diff * dirLightColor; gl_FragColor = vec4(materialColor * color, 1.0); }`;
      const vert=this._compile(gl.VERTEX_SHADER,vs);const frag=this._compile(gl.FRAGMENT_SHADER,fs);const program=gl.createProgram();gl.attachShader(program,vert);gl.attachShader(program,frag);gl.linkProgram(program);if(!gl.getProgramParameter(program,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(program));
      this.program=program;
      this.attribLocations={position:gl.getAttribLocation(program,'position'),normal:gl.getAttribLocation(program,'normal')};
      this.uniformLocations={modelMatrix:gl.getUniformLocation(program,'modelMatrix'),normalMatrix:gl.getUniformLocation(program,'normalMatrix'),viewMatrix:gl.getUniformLocation(program,'viewMatrix'),projectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),materialColor:gl.getUniformLocation(program,'materialColor'),dirLightColor:gl.getUniformLocation(program,'dirLightColor'),dirLightDirection:gl.getUniformLocation(program,'dirLightDirection'),ambientColor:gl.getUniformLocation(program,'ambientColor')};
    }
    _compile(type,src){const gl=this.gl;const shader=gl.createShader(type);gl.shaderSource(shader,src);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(shader));return shader;}
    render(scene,camera){const gl=this.gl;gl.enable(gl.DEPTH_TEST);gl.clearColor(scene.background.r,scene.background.g,scene.background.b,1);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
      camera.updateProjectionMatrix();camera.lookAt(new Vector3(0,1,-10));
      scene.updateWorldMatrix();
      const meshes=[];const gather=obj=>{if(obj instanceof Mesh){meshes.push(obj);}obj.children.forEach(gather);};gather(scene);
      gl.useProgram(this.program);
      gl.uniformMatrix4fv(this.uniformLocations.viewMatrix,false,camera.viewMatrix.elements);
      gl.uniformMatrix4fv(this.uniformLocations.projectionMatrix,false,camera.projectionMatrix.elements);
      gl.uniform3f(this.uniformLocations.dirLightColor,1,1,1);
      gl.uniform3f(this.uniformLocations.dirLightDirection,0.3,0.75,0.6);
      gl.uniform3f(this.uniformLocations.ambientColor,0.25,0.25,0.3);
      meshes.forEach(mesh=>{
        const geo=mesh.geometry; if(!geo._gl){geo._position=createGLBuffer(gl,geo.vertices,gl.ARRAY_BUFFER);geo._normal=createGLBuffer(gl,geo.normals,gl.ARRAY_BUFFER);geo._index=createGLBuffer(gl,geo.indices,gl.ELEMENT_ARRAY_BUFFER);geo._count=geo.indices.length;}
        const model=mesh.worldMatrix.elements;gl.uniformMatrix4fv(this.uniformLocations.modelMatrix,false,model);
        const normalMatrix=new Matrix4().identity(); // simplistic
        gl.uniformMatrix4fv(this.uniformLocations.normalMatrix,false,normalMatrix.elements);
        const c=mesh.material.color;gl.uniform3f(this.uniformLocations.materialColor,c.r,c.g,c.b);
        gl.bindBuffer(gl.ARRAY_BUFFER,geo._position);gl.enableVertexAttribArray(this.attribLocations.position);gl.vertexAttribPointer(this.attribLocations.position,3,gl.FLOAT,false,0,0);
        gl.bindBuffer(gl.ARRAY_BUFFER,geo._normal);gl.enableVertexAttribArray(this.attribLocations.normal);gl.vertexAttribPointer(this.attribLocations.normal,3,gl.FLOAT,false,0,0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,geo._index);
        gl.drawElements(gl.TRIANGLES,geo._count,gl.UNSIGNED_SHORT,0);
      });
    }
  }
  global.THREE={Vector3,Color,Matrix4,Object3D,Scene,PerspectiveCamera,BoxGeometry,PlaneGeometry,Group,MeshStandardMaterial,Mesh,AmbientLight,DirectionalLight,WebGLRenderer};
})(typeof window!=='undefined'?window:global);
